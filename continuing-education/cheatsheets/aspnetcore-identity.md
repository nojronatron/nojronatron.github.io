# ASP.NET Core Identity QuickRef

## Table of Contents

- [Architecture](#architecture)
- [Behavior](#behavior)
- [Configure](#configure)
- [Migrations](#migrations)
- [New User Registration](#new-user-registration)
- [Extend ID UI Components](#extend-id-ui-components)
- [Customize Multifactor Sign-in](#customize-multifactor-sign-in)
- [Implement Policy-based Authorization Using Claims](#implement-policy-based-authorization-using-claims)
- [Customize and Extend ID Data Store](#customize-and-extend-id-data-store)
- [Resources](#resources)

## Architecture

ASP.NET Core ID Stack:

- Razor Pages :arrow_down:
- ID Manager libraries :arrow_down:
- EF Core Identity Store :arrow_down:
- DB Provider :arrow_down:

## Behavior

User Sessions:

- Cookie created when sign-in succeeds
- Cookie destroyed upon logout

User Data:

- Persisted using any database supported by .NET EF Core
- Default is SQL Server
- Common relational schema tracks users, roles, logins, claims, and tokens

## Configure

Install and run generators for template scaffolder:

- Install `dotnet-aspnet-codegenerator` and a half-dozen NuGet packages
- Use `dotnet aspnet-codegenerator identity ...` to set up Identity in the current directory Project (this is the scaffolder)

Program.cs will be updated to include DBContext and Identity into the DI container.

Note: The generator focuses on UI-based Identity setup and configuration (as opposed to non-UI endpoints like an HTTP API).

Note: Sign-in and Registration links can be made available in the header using `<partial name="_LoginPartial" />` in `Pages/Shared/_Layout.cshtml`.

Note: The generator action creates Razor Class Libraries (RCLs) that define the Identity pages and behaviors. Therefore, UI changes require re-running `aspnet-codegenerator` to create the appropriate `cshtml` files. **However** documentation must be reviewed because the generator can **easily** create incorrect files for the wrong DBContext!

## Migrations

- Relies on dotnet-ef tool: `dotnet tool install dotnet-ef --version M.m.* --global`
- Migrate: `dotnet ef migrations add {migrationName}`
- Update the DB: `dotnet ef database update`

Note: Use VSCode Extension "SQL Server" to connect, or Visual Studio "SQL Object Explorer" to verify DB created and expected Tables exist.

## New User Registration

Configure The Confirmation Email Sender:

- Create an implementation of IEmailSender
- Register IEmailSender in DI
- The (no-op) email generated message can be set and have `{callbackUrl}` so the user knows what page to navigate to in order to complete registration
- The actual EmailSender implementation needs to have a public `Task SendEmailAsync(params)` method that returns `Task.CompletedTask`. In the MSFT example `Console.WriteLine()` is used to output the no-op email message.
- Add `Microsoft.AspNetCore.Identity.UI.Services` and the location of the EmailSender service to `Program.cs` and register it with DI

## Extend ID UI Components

Update IdentityUser:

- Use the IdentityUser class to add or update Properties per requirements.
- Leverage `System.ComponentModel.DataAnnotations` to set validation rules and requirements on the model properties.
- Run migrations and database update commands when done
- Chances are, pages that contain information about IdentityUser (profile forms, etc) will have to be updated to display and/or allow updating data for the new model properties.

Note: Profile management form could be `Areas/Identity/Pages/Account/Manage/Index.cshtml` depending on the deployment.

## Customize Multifactor Sign-in

MFA:

- Multiple forms of ID must be presented before authentication can be completed
- Code from an app, hardware token value, biometric scan, etc
- Enhances security
- Something the user knows (password, security Q), something they have (token, auth app), or something they are (biometric)

TOTP:

- Time based One Time Password
- Unique numerical codes that expire in 30 seconds
- Inputs: CurrentTime, Unique Key
- Supported by Authenticator services and Apps
- QR Code use is supported
- The 32-character **registration key** that is generated by Razor Pages template "Configure Authentication App" is the seed value for theh token

QR Codes:

- Client-side JS Libraries are available that can do this for you (see NuGet)
- ASPNET Core stores the QRCode as a base-64 encoded string
- The MFA Configuration Form can have a custom-generated QR Code added (see MSFT Learn for steps)

When a registered user selects "Add An Authenticator App", they can select 2-factor authentication then follow instructions to add the Authenticator and use the QR Code to register the App.

## Implement Policy-based Authorization Using Claims

Claims are:

- Name-value pairs
- Describe what the subject **is**
- Assigned by trusted authroity
- Used to enforce authorization policies

Secure a Page:

- Add the `[Authorize]` attribute to the page's class declaration (slightly different in Razor pages)
- Add using statement `Microsoft.AspNetCore.Authorization`
- Test a claim with code like `public bool IsAdmin => HttpContext.User.HasClaim("Admin", bool.TrueString);`
- If the test fails, call a forbidden page to tell the user they are not authorized
- If the test passes, execute the page code

Apply An Authorization Policy in Progoram.cs:

- Define an authorization policy named Admin
- Require the user to be authentication
- Require the user to hold the Admin claim (true)

```csharp
// define an authroization policy
builder.Services.AddRazorPages();
builder.Services.AddTransient<IEmailSender, EmailSender>();
builder.Services.AddSingleton(new QRCodeService(new QRCodeGenerator()));
builder.Services.AddAuthorization(options =>
    options.AddPolicy("Admin", policy =>
        policy.RequireAuthenticatedUser()
            .RequireClaim("IsAdmin", bool.TrueString)));

...

var app = builder.Build();
```

```csharp
// secure specific Razor pages in DI (instead of at the page itself)
builder.Services.AddRazorPages(options =>
    options.Conventions.AuthorizePage("/AdminsOnly", "Admin"));
```

Add The IsAdmin Claim To A User:

- Update `appsettings.json` to include "adminEmail" with the value of an admin
- Update ConfirmEmailModel page to use ConfigurationManager so it can read the IsAdmin claim

Check a Claim Programmatically:

- Read "AdminEmail" from the Configuration property
- Transform a null configuration to `string.Empty`
- If email is confirmed, call `AddClaimAsync()` method to save "IsAdmin" claim to the AspNetUserClaims table
- Setting a claim requires `System.Security.Claims` library

```json
// appsettings.json
...
{
  "AdminEmail": "admin@namespace.com",
  "Logging": {
    ...
  }
}
```

```csharp
// modify constructor to receive IConfiguration from the IoC container
public class ConfirmEmailModel : PageModel
{
    private readonly UserManager<RazorPagesPizzaUser> _userManager;
    private readonly IConfiguration Configuration;

    public ConfirmEmailModel(UserManager<RazorPagesPizzaUser> userManager,
                                IConfiguration configuration)
    {
        _userManager = userManager;
        Configuration = configuration;
    }
    ...
}
```

```csharp
// OnGetAsync method adds IsAdmin claim
public async Task<IActionResult> OnGetAsync(string userId, string code)
{
    if (userId == null || code == null)
    {
        return RedirectToPage("/Index");
    }

    var user = await _userManager.FindByIdAsync(userId);
    if (user == null)
    {
        return NotFound($"Unable to load user with ID '{userId}'.");
    }

    code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(code));
    var result = await _userManager.ConfirmEmailAsync(user, code);
    StatusMessage = result.Succeeded ? "Thank you for confirming your email." : "Error confirming your email.";

    var adminEmail = Configuration["AdminEmail"] ?? string.Empty;
    if(result.Succeeded)
    {
        var isAdmin = string.Compare(user.Email, adminEmail, true) == 0 ? true : false;
        await _userManager.AddClaimAsync(user, 
            new Claim("IsAdmin", isAdmin.ToString()));
    }

    return Page();
}
```

Verify A Claim Was Added:

- Open the SQL Explorer/Manager UI and either:
- Open AspNetUserClaims and view the users and the Claim Value, or
- Execute a SQL Inner Join query to acquire the usernames and their claims in one table

```sql
SELECT u.Email, c.ClaimType, c.ClaimValue
FROM dbo.AspNetUserClaims AS c
    INNER JOIN dbo.AspNetUsers AS u
    ON c.UserId = u.Id
```

**Note**: Each of these code segments is available from [Microsoft Learn](https://learn.microsoft.com/en-us/training/modules/secure-aspnet-core-identity/)

## Customize and Extend ID Data Store

The Identity data model can be customized:

- Represents a user as `IdentityUser` class

## Resources

- [ASP.NET Core Security](https://learn.microsoft.com/en-us/aspnet/core/security/)
- [Scaffold Identity in ASP.NET Core projects](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/scaffold-identity)
- [Identity model customizations in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model)
- [Enable QR Code Generation and TOTP Auth in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-enable-qrcodes)
- [Claims-based Auth in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/claims)
